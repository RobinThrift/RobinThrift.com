<body>
  <!DOCTYPE html>
<html lang="en-gb">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta content="" name="keywords">
<meta content="Error Handling in Swift? - Robin Thrift" property="og:title">
<title>Error Handling in Swift? | Robin Thrift</title>
<link rel="stylesheet" href="http://robinthrift.com//css/style.css">
<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/gruvbox-dark.min.css">


  <section class="section">
  <div class="container">
    <nav class="nav">
      <div class="nav-left">
        <a class="nav-item" href="http://robinthrift.com//"><h1 class="title is-4">Robin Thrift</h1></a>
      </div>
      <div class="nav-right">
        <nav class="nav-item level is-mobile">
          
          <a class="level-item" href="https://github.com/RobinThrift">
            <span class="icon">
              <i class="fa fa-github"></i>
            </span>
          </a>
          
          <a class="level-item" href="https://twitter.com/RobinThrift">
            <span class="icon">
              <i class="fa fa-twitter"></i>
            </span>
          </a>
          
          <a class="level-item" href="/index.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>
          </a>
          
        </nav>
      </div>
    </nav>
  </div>
</section>

  <section class="section">
    <div class="container">
      <h2 class="subtitle is-6">July 3, 2017</h2>
      <h1 class="title">Error Handling in Swift?</h1>
      
      <div class="tags">
    
        <a class="button is-link" href="/tags/swift">swift</a>
    
</div>

      
      <div class="content">
        

<p>I&rsquo;ve been writing a lot of Swift recently, both for iOS and macOS (maybe some server side Linux stuff in future too). Whenever you learn a new language you initially take some idioms from other languages with you. I am primarily a JavaScript developer, where, due to the nature of things, most operations are asynchronous, so they are wrapped in promises. Error handling in this case is mostly handled in anonymous functions where the first parameter is the error object:</p>

<pre><code class="language-javascript">fs.readFile('some/file.ext')
    .then((content) =&gt; {
        // do something with the content...
    })
    .catch((error) =&gt; {
        console.error(error)
    })
</code></pre>

<p>Recently though this has changed through the use of <code>async/await</code>. Instead of using the <code>catch</code> callback on a promise we are back to <code>try/catch</code>:</p>

<pre><code class="language-javascript">try {
    let content = fs.readFile('some/file.ext')
    // do something with the content...
} catch (error) {
    console.error(error)
}
</code></pre>

<p>While <code>asnyc/await</code> is amazingly useful, we&rsquo;ve come full circle, back to exceptions like in Java, C# or C++ where I&rsquo;ve seen a lot of code like the following.</p>

<pre><code class="language-java">try {
    String contents = new File(&quot;some/file.ext&quot;).readAll()
} catch (IOException e) {}

</code></pre>

<p>Or worse, just letting the method throw, bubbling up the call chain.</p>

<p>Having worked with both Go and Rust this felt a little backwards. Go especially used to advertise with the premise that they didn&rsquo;t have any exceptions (there are <a href="https://github.com/golang/go/wiki/PanicAndRecover">panics</a> however). Instead, Go and Rust make error handling a core part of programming, not an &ldquo;exception&rdquo;.
I don&rsquo;t want to go into too much detail about Rust or Go, but here&rsquo;s a very quick recap of how they handle errors.</p>

<p><strong>Rust:</strong></p>

<pre><code class="language-rust">// opened `file` above (error also dealt with using `match`)
let mut s = String::new();
match file.read_to_string(&amp;mut s) {
    Err(why) =&gt; panic!(&quot;couldn't read file: {}&quot;, why.description()),
    Ok(_) =&gt; print!(&quot;contents:\n{}&quot;, s),
}
</code></pre>

<p>Rust uses the <a href="https://doc.rust-lang.org/std/result/"><code>Result&lt;T, E&gt;</code></a>-type; an enum that covers the two possible cases of an operation:</p>

<pre><code class="language-rust">enum Result&lt;T, E&gt; {
   Ok(T),
   Err(E),
}
</code></pre>

<p><strong>Go:</strong></p>

<pre><code class="language-go">dat, err := ioutil.ReadFile(&quot;/some/file.ext&quot;)
if err != nil {
	//...
}
</code></pre>

<p>Go uses multiple return parameters to inform the user that a function could return an error. While it may be a little less elegant than Rust&rsquo;s <code>Result</code>-type the error handling is very expressive.</p>

<h3 id="errors-in-swift">Errors in Swift?</h3>

<p>So finally, after we&rsquo;ve set the playing field we get to Swift. Reading about Swift and how much it seemingly took out of the functional (and in turn Rust&rsquo;s) playbook I was excited to see what the Swift team had come up with. Queue my disappointment when I saw the examples and they defaulted to &ldquo;old school&rdquo; <code>try/catch</code>. Seems like a bit of a waste of the type system. So when writing Swift code, especially asynchronous code, I needed a way other than just throwing an error out there, hoping someone would catch it. Maybe it&rsquo;s due to my inexperience with Swift that I did not like the uncertainty of <code>throw</code>ing.</p>

<p>Initially I tried Go-style tuples and destructuring as a kind of &ldquo;fake&rdquo; multiple return parameters. So a function that could fail looked this:</p>

<pre><code class="language-swift">func readFile(path: String) -&gt; (String?, Error?) {
    do {
        let content = try String(contentsOf: path, encoding: String.Encoding.utf8) 
        return (content, nil)
    } catch (let e) {
        return (nil, e)
    }
}
</code></pre>

<p>This worked, and solved my problem, but it meant that everything had to be declared as optional. So instead of using the type system to my advantage, encoding logic in types, I threw away some type safety and convenience. So after a while I decided to switch to Rust-style <code>Result</code>s:</p>

<p>I created my own <code>Result</code>-enum:</p>

<pre><code class="language-swift">enum Result&lt;T&gt; {
    case Value(T)
    case Error(Error)
}
</code></pre>

<pre><code class="language-swift">func readFile(path: String) -&gt; Result&lt;String&gt; {
    do {
        let content = try String(contentsOf: path, encoding: String.Encoding.utf8) 
        return .Value(content)
    } catch (let e) {
        return .Error(e)
    }
}
</code></pre>

<p>Now I could use <code>switch</code> statements to handle my errors:</p>

<pre><code class="language-swift">switch readFile(&quot;some/file.ext&quot;) {
case .Value(let content):
    print(content)
case .Error(let error):
    print(error)
}
</code></pre>

<p>In future I could even extend the <code>Result</code> enum using functions like <code>map</code> or <code>flatten</code> to make handling errors even easier. I can pass the result around, confident that the type system will make sure I don&rsquo;t do anything stupid (spoiler alert: I will find a way regardless).</p>

<p>I&rsquo;m not sure if this is the most idiomatic way to handle errors in Swift, but it certainly beats <code>try/catch</code> for me.</p>

      </div>
    </div>
  </section>
  

  <section class="section">
  <div class="container has-text-centered">
    <p>&copy; <a href="https://github.com/RobinThrift">Robin Thrift</a> 2017</p>
  </div>
</section>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/rust.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>

<script>hljs.initHighlightingOnLoad();</script>


</body>
