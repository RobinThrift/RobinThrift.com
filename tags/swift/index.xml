<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>swift on Robin Thrift</title>
    <link>https://robinthrift.com/tags/swift/</link>
    <description>Recent content in swift on Robin Thrift</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <copyright>&amp;copy; &lt;a href=&#34;https://github.com/RobinThrift&#34;&gt;Robin Thrift&lt;/a&gt; 2022</copyright>
    <lastBuildDate>Sun, 07 Oct 2018 00:00:00 +0100</lastBuildDate><atom:link href="https://robinthrift.com/tags/swift/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Detecting MIME type and file extension in Swift (using Uniform Type Identifiers)</title>
      <link>https://robinthrift.com/post/swift-detect-mime-and-filetype/</link>
      <pubDate>Sun, 07 Oct 2018 00:00:00 +0100</pubDate>
      
      <guid>https://robinthrift.com/post/swift-detect-mime-and-filetype/</guid>
      <description>Why do we want to detect the MIME type or file extension? The Matrix spec defines several messaging types for attachments (essentially binary blobs). The generic m.file can be used to send any type of file as an attachment. Common file types like audio, video, and especially images however have their own message type (m.audio, m.video and m.image respectively). So when sending images (or video, or audio) we want to send it using the appropriate message type.</description>
    </item>
    
    <item>
      <title>Error Handling in Swift?</title>
      <link>https://robinthrift.com/post/swift-error-handling/</link>
      <pubDate>Mon, 03 Jul 2017 00:00:00 +0100</pubDate>
      
      <guid>https://robinthrift.com/post/swift-error-handling/</guid>
      <description>I&amp;rsquo;ve been writing a lot of Swift recently, both for iOS and macOS (maybe some server side Linux stuff in future too). Whenever you learn a new language you initially take some idioms from other languages with you. I am primarily a JavaScript developer, where, due to the nature of things, most operations are asynchronous, so they are wrapped in promises. Error handling in this case is mostly handled in anonymous functions where the first parameter is the error object:</description>
    </item>
    
  </channel>
</rss>
